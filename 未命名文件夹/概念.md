


Class

## 1.前后端分离:
前端：与游览器对话 只处理页面内容
后端：与数据库对话

spa出现 前后端分离开发
## 2.ssr与spa区别:

    * 单页应用(spa)     VS     服务端渲染(ssr)

    
    ssr:
            优点：首次加载时间短
                SEO效果好
            缺点：切换页面慢，每次都要重新请求html
                服务端渲染，增大服务器压力


    spa: 
        优点：切换页面快，只是将当前页面的内容清除掉，然后下一个页面的内容挂载到当前页面上
            按条件渲染，减少了重绘回流，提高了渲染速度(*)
            浏览器渲染，减小服务器压力(*)
        缺点：首次加载没有ssr快，SEO效果差
        
    eg： 后台管理页面，slide+nav。。。 都不需要重新渲染

###  重绘：
            当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color
###  回流：
            当render tree中的一部分(或全部)因为元素的规模尺寸、布局、某些属性等改变而需要重新构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的，因为要构建render tree。

## 3.前端路由:

特点：不向后台发送请求，不刷新页面，前后端分离

前端路由即响应页面内容的任务是由前端来做的，根据不同的url更新页面的内容，随着SPA（单页面应用）的普遍使用，前后端开发分离，项目中基本都使用前端路由，通过路由实现页面的变化。例如，通过vue开发的SPA中，切换路由，并不刷新页面，而是根据路由在虚拟DOM中加载所需要的数据，实现页面内容的改变。

优点：

1.用户体验好，页面初始化后，只需要根据路由变换页面内容，不需要再向服务器发送请求，内容变换速度快。

2.可以在浏览器中输入指定想要访问的url

3.实现了前后端分离，方便开发。

缺点：

1.使用浏览器的前进、后退键的时候会重新发送请求，没有合理的利用缓存

2.单页面无法记住之前滚动的位置，无法在前进、后退的时候记住滚动的位置

## 4.为啥要组件化？:
将项目中大量重复的元素抽成公共的组件。 

## 5.虚拟dom ：
当浏览器收到一个dom修改操作时，它不知道后面还有没有其他DOM操作，会马上执行当前dom更新操作
假如一个js操作中有20个dom更新，那么真实DOM会执行20次，如果这20个里面有有同一个元素多次操作，每次都会执行，上一次的更新就是无用功，白白更新了一次。
那么虚拟dom，他收到更新时，不会立马执行dom修改，会将更新生成新的虚拟dom树，用新树和旧树进行对比（diff算法），记录这两棵树差异。差异部分 是我们需要对页面真正的DOM操作部分，然后执行真正的DOM更新

### diff算法：
diff算法即在实际dom进行更新的时候，将虚拟dom树和实际的dom树进行比较之后根据差异，进行更新。而实际dom中对某个元素进行多次更新之后，只会保留最后一次更新的状态。

## 6.v-for 的key
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，如果使用index作为key值它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。所以不用数组下标作为key值。

给元素绑定一个唯一的标识符来告诉游览器你要操作的元素是谁。（如果使用index作为key值它默认用“就地复用”策略。）

## 7.Object.definedProperty

答：通过Object.definedProperty里面的set和get进行数据的双向绑定。vue中在创建元素阶段，会遍历页面中的各个数据或者状态，自动给他们通过这个方法来进行数据绑定。但是在vue中无法直接监听property的变化，得通过forceupdate(）来进行数据强制更新或者this.$set来进行新数据的绑定

## 8.箭头函数的this

答：箭头函数没有自己的this，会自动继承父级的作用域里面的this指向， 否则指向全局，并且绑定之后就不会改变。（1.js中对象没有作用域，即在对象内部的作用域链中采取就近原则获取变量最终的值。2.箭头函数继承不到父级对象的this时，会继承全局的this指向）

## 9.new的作用

答：1.创建一个新的对象

2.将this指向这个对象

3.执行构造函数的代码，给这个对象添加属性和方法

4，返回这个对象

## 10.解构函数

答：相当于浅拷贝，只解构一层，内部的函数和对象会直接拷贝地址

## 11.class extends constructor  super

答：相当于对构造函数和prototype方法的语法糖

1.带有class关键字的对象和由function创建的构造函数不同，不能直接运行，只是作为一个对象表示

2.constructor表示这个对象的构造函数

3.extends:即继承,本质是原型链的继承的语法糖

4.super:子类在继承父类之后必须在构造函数中使用super,如果没有构造函数，constructor方法和super方法会默认添加。当super当函数使用时，指代父类的构造函数并进行parent的this的重定向；当对象使用时，指向父类的原型对象。
